<?xml version="1.0" encoding="utf-8"?>
<!-- $Revision: $ -->
<!-- EN-Revision: 7104ee97ced1768a3231588dfc0bc0d7eb1117ad Maintainer: Serge Status: wip -->
<!-- Reviewed: no -->

<sect1 xml:id="control-structures.match" xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink">
 <title>match</title>
 <?phpdoc print-version-for="match"?>
 <para>
  La structure <literal>match</literal> dirige l'évaluation d'après
  une comparaison d'identité( <code>===</code>) entre l'objet soumis et les expressions conditionnelles.
  Similaire à une instruction <literal>switch</literal>,
  la structure <literal>match</literal> évalue l'expression de retour associé à l'ambranchement correspondant.
  
  Contrairement à <literal>switch</literal>, <literal>match</literal> évaluera
  la valeur un peu comme les structures conditionnelles ternaires.
  Contrairement à <literal>switch</literal>, la condition est une comparaison
  d'identité plutôt qu'une comparaison d'égalité( <code>==</code>) .
  Les structures <literal>match</literal> sont disponibles à partir de PHP 8.0.0.
 </para>

 <example>
  <title>Structure d'une expression <literal>match</literal></title>
  <programlisting role="php">
<![CDATA[
<?php
$return_value = match (subject_expression) {
    single_conditional_expression => return_expression,
    conditional_expression1, conditional_expression2 => return_expression,
};
?>
]]>
  </programlisting>

  <note>
   <simpara>
    La valeur de retour d'une structure <literal>match</literal> est optionnelle.
   </simpara>
  </note>
  <note>
   <simpara>
    Une structure <literal>match</literal> <emphasis>doit</emphasis> être
    terminée par le caractère de fin d'instruction <literal>;</literal>.
   </simpara>
  </note>
 </example>

 <para>
  Une structure <literal>match</literal> est similaire à une instruction
  <literal>switch</literal> mais possède quelques différences clés :
  
  <itemizedlist>
   <listitem>
    <simpara>
     Un embranchement de <literal>match</literal> compare les valeurs
     à l'identique( <code>===</code>) contrairement à l'instruction
     <literal>switch</literal> qui le fait à l'égalité( <code>==</code>).
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Une structure <literal>match</literal> retourne une valeur.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Un embranchement de <literal>match</literal> ne passe pas aux
     cas ultérieurs comme le fait une instruction <literal>switch</literal>.
    </simpara>
   </listitem>
   <listitem>
    <simpara>
     Une structure <literal>match</literal> doit être exhaustive.
    </simpara>
   </listitem>
  </itemizedlist>
 </para>

 <para>
  Comme les instructions <literal>switch</literal> les structures
  <literal>match</literal> évaluent l'objet soumis et,
  selon le résultat obtenu et l'embranchement correspondant,
  l'expression de retour associé.

  Les expressions conditionnelles sont seulement évaluées si toutes les
  conditions précédentes ont échoué. Seule l'expression de retour
  correspondant à l'embranchement sera évaluée.
  Par exemple :
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$result = match ($x) {
    foo() => ...,
    $this->bar() => ..., // bar() n'est pas appelé si foo() === $x
    $this->baz => beep(), // beep() n'est pas appelé à moins que $x === $this->baz
    // etc.
};
?>
]]>
   </programlisting>
  </informalexample>
 </para>

 <para>
  Les embranchements d'une structure <literal>match</literal> peuvent contenir
  plusieurs conditions séparées par une virgule. C'est un OU logique,
  et c'est un raccourci pour plusieurs embranchement similaires. 
 </para>
 <para>
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$result = match ($x) {
    // Cet embranchement :
    $a, $b, $c => 5,
    // Équivaut à ces trois embranchements :
    $a => 5,
    $b => 5,
    $c => 5,
};
?>
]]>
   </programlisting>
  </informalexample>
 </para>
 <para>
  Un cas particulier est la clause <literal>default</literal>.
  Cette clause est évaluée à défaut de condition vérifiée.
  Par exemple:
  <informalexample>
   <programlisting role="php">
<![CDATA[
<?php
$expressionResult = match ($condition) {
    1, 2 => foo(),
    3, 4 => bar(),
    default => baz(),
};
?>
]]>
   </programlisting>
  </informalexample>
  <note>
   <simpara>
    Plusieurs clauses <literal>default</literal> soulèveront une erreur
    <constant>E_FATAL_ERROR</constant>.
   </simpara>
  </note>
 </para>

 <para>
  Une structure <literal>match</literal> doit être exhaustive.
  Si l'objet soumise ne correspond à aucun embranchement, une erreur
  <classname>UnhandledMatchError</classname> est soulevée.
 </para>

 <example>
  <title>Exemple d'embranchement absent</title>
  <programlisting role="php">
<![CDATA[
<?php
$condition = 5;

try {
    match ($condition) {
        1, 2 => foo(),
        3, 4 => bar(),
    };
} catch (\UnhandledMatchError $e) {
    var_dump($e);
}
?>
]]>
  </programlisting>
  &example.outputs;
  <screen>
<![CDATA[
object(UnhandledMatchError)#1 (7) {
  ["message":protected]=>
  string(33) "Unhandled match value of type int"
  ["string":"Error":private]=>
  string(0) ""
  ["code":protected]=>
  int(0)
  ["file":protected]=>
  string(9) "/in/ICgGK"
  ["line":protected]=>
  int(6)
  ["trace":"Error":private]=>
  array(0) {
  }
  ["previous":"Error":private]=>
  NULL
}
]]>
  </screen>
 </example>

 <sect2>
  <title>Utilisation de match pour gérer les expressions conditionnelles</title>
  <para>
   Il est possible d'utiliser une structure <literal>match</literal> avec
   <code>true</code> comme objet soumise pour gérer les expressions conditionnelles.
  </para>

  <example>
   <title>Embranchement basé sur une plage d'entier</title>
   <programlisting role="php">
<![CDATA[
<?php

$age = 23;

$result = match (true) {
    $age >= 65 => 'sénior',
    $age >= 25 => 'adulte',
    $age >= 18 => 'majeur',
    default => 'mineur',
};

var_dump($result);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
string(11) "majeur"
]]>
   </screen>
  </example>

  <example>
   <title>Embranchement basé sur du texte</title>
   <programlisting role="php">
<![CDATA[
<?php

$text = 'Bienvenue chez nous';

$result = match (true) {
    str_contains($text, 'Welcome') || str_contains($text, 'Hello') => 'en',
    str_contains($text, 'Bienvenue') || str_contains($text, 'Bonjour') => 'fr',
    // ...
};

var_dump($result);
?>
]]>
   </programlisting>
   &example.outputs;
   <screen>
<![CDATA[
string(2) "fr"
]]>
   </screen>
  </example>
 </sect2>
</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:t
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
indent-tabs-mode:nil
sgml-parent-document:nil
sgml-default-dtd-file:"~/.phpdoc/manual.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:nil
sgml-local-ecat-files:nil
End:
vim600: syn=xml fen fdm=syntax fdl=2 si
vim: et tw=78 syn=sgml
vi: ts=1 sw=1
-->
